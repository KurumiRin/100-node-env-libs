# 从 cac 学会做一个工具的要素

最近看了 [`cac`](https://github.com/cacjs/cac), 一个很简单的库，用于解析命令行参数，并执行对应命令的 `action`：

以下是一个简单的示例：

```ts
import { cac } from 'cac'

const cli = cac()

cli.command('dev <file>', 'run dev server based on specify file')
  .open('--open', 'open file')
  .action((file, options) => {
    console.log(file, options)
  })

const args = ['_', 'index.js', 'dev', 'server.ts', '--open']

cli.parse(args)
```

那么这个库的使用场景在哪里呢？

## 前言

### 使用场景

假设我们写了一个函数，可以创建文件：

```ts
import { writeFileSync } from 'fs'

function createFile(filePath: string) {
  writeFileSync(filePath, '')
}
```

那么常规的方法，你需要这样：

- 创建一个文件，引入这个函数，并传递文件路径

```ts
import { resolve } from 'fs'
import { createFile } from 'path-to-your-file'

createFile(resolve(process.cwd(), 'test.txt'))
```

- 并在 node 环境中执行这个文件

```bash
node index.js
```

那么痛点在哪里：

- 你想执行这个函数，需要启动一个文件
- 需要执行哪些函数，需要传递怎么样的数据，你需要事先知道
- 如果需要创建多个文件（即参数是变化的），那么你的文件代码你要时不时的变动

### 解决痛点的方式

很快你想到了一种方式，你知道可以通过 `process.argv` 用于得到执行文件的参数，即：

```bash
node index.js foo bar 
```
```ts
// 结果：
// ['your node.js executable file path', 'index.js', 'foo', 'bar']
console.log(process.argv)
```

所以稍加改造，你就能实现根据传入的不同参数，来执行函数：

```ts
import { resolve } from 'fs'
import { createFile } from 'path-to-your-file'

const fileName = process.argv[2]

createFile(resolve(process.cwd(), fileName))
```

但是新的问题来了，如果你还想传递不同的参数，你需要添加更为复杂的逻辑，可能写着写着，功能越来越复杂，代码也越来越混乱。

### 优化解决痛点的方式：

那么很快，你又想到的一种优化的方法，即对代码的解析进行抽象，只需要向外暴露一些 api，例如注册指令，执行回调函数等等

于是，你先设计了一些 api

- `command` 用于注册指令
- `action` 用于执行匹配指令的回调函数

你同时设想了一些使用场景：

- 可以通过注册不同的指令来执行不同的功能
- 可以注册多个不同的解析器，并且互不影响

处于这两者的考虑，你选择 `OOP` 作为开发范式

很快，你就造出了一个可以用的简单轮子，不仅提高了开发体验，也对`开发工具`这件事有了一个新的认知。

## 做工具的要素

从上文中的例子就能看出，造轮子不是一件困难的事情，更谈不上技术壁垒。

想要实现功能，并不难。难的是如何合理、优雅、快捷的组织代码。在阅读 CAC 源码的途中，我想，他大概带给了我这几个开发轮子的要素建议：

### 测试驱动 

在 `CAC` 的项目结构中，使用 `jest` 作为单元测试框架

至于测试驱动开发，对于开发轮子的过程来说，有这几个好处：

- 理清开发思路
- 测试即需求，通过测试即通过需求
- 重构不需要担心功能产生破坏

我们来感受一下，下面是一个测试：

```ts
test('get sum', () => {
  expect(sum(2, 3)).toBe(5)
})
```

我们先写了一个测试，下面由结果来反推过程

```ts
function sum(n1: number, n2: number) {
  return n1 + n2
}
```

运行测试，测试通过即代表功能正常，不通过即代表存在 bug

后面，如果我们需要修改这个函数：

```ts
function sum(n1: number, n2: number) {
  return n2 + n1
}
```

重构完成函数，只需要运行测试，通过表示功能正常，不通过那就是重构出现了问题

同时，测试还可以帮助你串联逻辑，减轻思考的负担：

- 假设你需要开发一个很大的框架，框架由不同的函数所组成
- 编写颗粒度至单个函数的测试（甚至单个函数的单个分支），每次实现的功能仅仅局限于单个函数
- 最后测试全部通过，框架也已经做完。
- 所以测试，还有助于理清开发思路

不过以测试驱动开发主要注意一点的是，编写测试需要考虑完善情况，这样才能保证程序的健壮性

### 找到痛点，细化需求

就像是前文中说到的那样，也许我在实现某个功能，但是实现这个需求的过程中，发现了部分内容实现起来比较难受。注意，这就是痛点

那么有了痛点，就可以根据一些特定的需求来造轮子了。千万不要一开始就有一个宏伟的目标，例如实现一个轮子，可以创造一个宇宙。过大的目标会导致功能实现起来有些茫然

`CAC` 的做法就是，找到自己需要做的事情。

他只是用于解析命令行参数，执行指定的回调就可以了。那么假设你要造一个创造宇宙的轮子：

- 你先造一个创造天体的轮子
- 你再造一个创造空间的轮子
- 你再造一些其他方面的轮子
- 最终所有轮子组合，就是一个创造宇宙的轮子

你可以试试先给自己的需求列一个清单，专注于某些需求来实现特定的轮子。

在 `CAC` 中，就依赖 `mri` 用于对命令行参数转换。

### 尽量通用化

造工具，目的有两个：

- 复用
- 细化需求

所以一个比较重要的问题就是复用，如果你想让你的工具受到更多人的使用，那么就必须要尽量通用化

可能会有人有疑惑，为什么要通用化，还要细化需求呢？

其实这里的重要点就是对需求进行抽象化，再实现相对通用的轮子（这样轮子在下次类似的需求中也能排上用场）

对于 CAC 来说，通用性就是支持较多需求的 command 解析，例如 `brackets` 来实现可选必选参数，可以使用 `options` 等等

这里的通用化，也有考虑通用应用场景的情况。在开发工具的早期，你就可以先根据具体细化的需求抽象出一些使用场景。

最后再根据具体的情况实现与否。

### 选择合适的技术栈和开发范式

开发轮子还有一个重要点，选择合适的技术和开发范式。其实这里也是根据上一点而实现的。

譬如 CAC 的使用场景可能存在多个解析器，那么使用 OOP 显然比使用函数式更加的简单（因为携带信息和信息私有化更加方便）

所以要根据不同的功能来选择不同的开发范式和技术栈

### 优化使用者的体验

当然，为了让自己的轮子让更多的用，除了让轮子更加通用，优化使用者的体验也是必需的

优化使用者的体验包括但不限于：

- 写好 README.md
- 写好使用样例
- 代码做好兜底保护，抛出合理的错误
- 做出多个兼容版本，例如 CAC 就存在 ESM、CJS 和 deno 三个版本


### 为后续维护提供便利

当你的轮子有越来越多人用的时候，为了不流失这些用户，维护是必然的。

为了降低维护的成本，可以上一些 CI, 譬如 CAC 中就用到了 `CircleCI`

构建 CI 也可以为提供测试其他贡献者代码功能是否正常的功能，对于某个项目的 maintainer 或 owner 来说是很有帮助的

当然我也推荐你使用 `Github Action`。

也可以为自己的项目写一些便利的脚本，例如 CAC 中就会 build deno version 的脚本

每次构建 deno 版本直接运行脚本就足够。


## 后话

还是那句话，造轮子并不难，难的是如何合理、规范、快速、优化的组织代码。

要想造好轮子，好造轮子，一些基本的素养是需要知道的。
